{"meta":{"title":"Tom的博客","subtitle":"加油加油鸭","description":"某985硕士","author":"Tom","url":"http://example.com","root":"/"},"pages":[{"title":"about","date":"2021-12-17T15:45:41.000Z","updated":"2021-12-17T17:17:02.443Z","comments":false,"path":"about/index.html","permalink":"http://example.com/about/index.html","excerpt":"","text":"关于我某小小程序员，想要成长！ 网页变动 2021.12.18 增加数据库、计算机网络、操作系统的md文件，还没有想好写啥呢。 2021.12.17 想要建立系列文章，以后尽量以【面试题目】来作为文章标题，然后尝试创建专栏。 改动：redis 双写一致性 和 redis分布式锁。 donors 社会闲散人员 - momo 黄*豪 邓*得 杨*媛 李*昂感谢以上名单的人员，排名不分先后！ 【彩蛋-我的学姐】我的学姐是一个非常独特的女生，角度清奇，能力一流～很多东西都是她教我的，基础也很好！学姐加油鸭！ 2021-12-18 凌晨12:18 访问量 2021.12.17 总访问量 616 次 总访客数 228 人"}],"posts":[{"title":"","slug":"操作系统","date":"2021-12-17T17:05:14.578Z","updated":"2021-12-17T17:05:14.578Z","comments":true,"path":"2021/12/18/操作系统/","link":"","permalink":"http://example.com/2021/12/18/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"","slug":"数据库","date":"2021-12-17T17:04:55.738Z","updated":"2021-12-17T17:04:55.738Z","comments":true,"path":"2021/12/18/数据库/","link":"","permalink":"http://example.com/2021/12/18/%E6%95%B0%E6%8D%AE%E5%BA%93/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"","slug":"计算机网络","date":"2021-12-17T17:04:42.425Z","updated":"2021-12-17T17:04:42.425Z","comments":true,"path":"2021/12/18/计算机网络/","link":"","permalink":"http://example.com/2021/12/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"【MAC】使用技巧","slug":"MAC使用","date":"2021-12-17T16:01:33.000Z","updated":"2021-12-17T17:54:48.007Z","comments":true,"path":"2021/12/18/MAC使用/","link":"","permalink":"http://example.com/2021/12/18/MAC%E4%BD%BF%E7%94%A8/","excerpt":"新拿到一个新的MAC，你该怎么办？","text":"1. 开发 iTerm2，非常好用的控制台程序 oh my zsh git 2. 使用 微信 音乐播放软件-酷狗/网易云等 谷歌浏览器 - 油猴助手（太多好用插件了） 3. 一些链接分享3.1 我开了vpn了，git网页能进去，但是为什么我的git push 或者 git clone 都特别慢 原因：没有设置代理,为什么慢是因为你没有使用你的vpn，还是原来的网络环境解决方法： vim ~/.gitconfig 检查一下是否设置了你vpn的代理然后设置代理 12设置代理方法即可解决(请自行查找你的vpn的http代理端口)git config --global http.proxy &quot;localhost:port&quot; 怎么取消？ 1git config --global --unset http.proxy","categories":[{"name":"教程","slug":"教程","permalink":"http://example.com/categories/%E6%95%99%E7%A8%8B/"}],"tags":[{"name":"MAC","slug":"MAC","permalink":"http://example.com/tags/MAC/"},{"name":"教程","slug":"教程","permalink":"http://example.com/tags/%E6%95%99%E7%A8%8B/"}]},{"title":"【面试题目】---redis","slug":"Redis","date":"2021-12-17T12:05:10.000Z","updated":"2021-12-17T16:54:36.383Z","comments":true,"path":"2021/12/17/Redis/","link":"","permalink":"http://example.com/2021/12/17/Redis/","excerpt":"redis数据类型，双写一致性，分布式锁等。","text":"1. 分布式锁分布式锁是为了实现强一致性，例如 多个用户多个微服务去抢购物车100个限量商品，由于访问的是不同的机器，所以这个100可能是不准确的。 有两个线程（分别叫T1,T2）做的都是同样的事情，拿到一个叫做A的资源，然后对其进行+1操作。由于线程之间是不会互相通信的，于是就有可能出现下面这种情况：T1拿到A，读入内存，此时A值为T；T2拿到A，读入内存，此时A值为T；T1进行+1操作，此时A实际值为T+1；T2进行+1操作，此时A的实际值仍然为T+1; 1.1 分布式锁应该具备哪些条件？在分析分布式锁的三种实现方式之前，先了解一下分布式锁应该具备哪些条件： 在分布式系统环境下，一个方法在同一时间只能被一个机器的一个线程执行； 高可用的获取锁与释放锁； 高性能的获取锁与释放锁； 具备可重入特性； 具备锁失效机制，防止死锁； 具备非阻塞锁特性，即没有获取到锁将直接返回获取锁失败。 1.2 实现分布式锁的三种方式？ 基于数据库实现分布式锁；基于缓存（Redis等）实现分布式锁；基于Zookeeper实现分布式锁； 1.2.1 基于数据库的锁机制基于数据库的实现方式的核心思想是：在数据库中创建一个表，表中包含方法名等字段，并在方法名字段上创建唯一索引，想要执行某个方法，就使用这个方法名向表中插入数据，成功插入则获取锁，执行完成后删除对应的行数据释放锁。 (1) 创建一个表 123456789DROP TABLE IF EXISTS `method_lock`;CREATE TABLE `method_lock` ( `id` int(11) unsigned NOT NULL AUTO_INCREMENT COMMENT &#x27;主键&#x27;, `method_name` varchar(64) NOT NULL COMMENT &#x27;锁定的方法名&#x27;, `desc` varchar(255) NOT NULL COMMENT &#x27;备注信息&#x27;, `update_time` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP, PRIMARY KEY (`id`), UNIQUE KEY `uidx_method_name` (`method_name`) USING BTREE) ENGINE=InnoDB AUTO_INCREMENT=3 DEFAULT CHARSET=utf8 COMMENT=&#x27;锁定中的方法&#x27;; （2）想要执行某个方法，就使用这个方法名向表中插入数据： INSERT INTO method_lock (method_name, desc) VALUES (‘methodName’, ‘测试的methodName’);因为我们对method_name做了唯一性约束，这里如果有多个请求同时提交到数据库的话，数据库会保证只有一个操作可以成功，那么我们就可以认为操作成功的那个线程获得了该方法的锁，可以执行方法体内容。 （3）成功插入则获取锁，执行完成后删除对应的行数据释放锁： delete from method_lock where method_name =’methodName’; 注意：这只是使用基于数据库的一种方法，使用数据库实现分布式锁还有很多其他的玩法！ 使用基于数据库的这种实现方式很简单，但是对于分布式锁应该具备的条件来说，它有一些问题需要解决及优化： 1、因为是基于数据库实现的，数据库的可用性和性能将直接影响分布式锁的可用性及性能，所以，数据库需要双机部署、数据同步、主备切换； 2、不具备可重入的特性，因为同一个线程在释放锁之前，行数据一直存在，无法再次成功插入数据，所以，需要在表中新增一列，用于记录当前获取到锁的机器和线程信息，在再次获取锁的时候，先查询表中机器和线程信息是否和当前机器和线程相同，若相同则直接获取锁； 3、没有锁失效机制，因为有可能出现成功插入数据后，服务器宕机了，对应的数据没有被删除，当服务恢复后一直获取不到锁，所以，需要在表中新增一列，用于记录失效时间，并且需要有定时任务清除这些失效的数据； 4、不具备阻塞锁特性，获取不到锁直接返回失败，所以需要优化获取逻辑，循环多次去获取。 5、在实施的过程中会遇到各种不同的问题，为了解决这些问题，实现方式将会越来越复杂；依赖数据库需要一定的资源开销，性能问题需要考虑。 1.2.2 基于redis的锁机制1、选用Redis实现分布式锁原因： （1）Redis有很高的性能；（2）Redis命令对此支持较好，实现起来比较方便 2、使用命令介绍： （1）SETNX SETNX key val：当且仅当key不存在时，set一个key为val的字符串，返回1；若key存在，则什么都不做，返回0。 （2）expire expire key timeout：为key设置一个超时时间，单位为second，超过这个时间锁会自动释放，避免死锁。 （3）delete delete key：删除key 在使用Redis实现分布式锁的时候，主要就会使用到这三个命令。 3、实现思想： （1）获取锁的时候，使用setnx加锁，并使用expire命令为锁添加一个超时时间，超过该时间则自动释放锁，锁的value值为一个随机生成的UUID，通过此在释放锁的时候进行判断。 （2）获取锁的时候还设置一个获取的超时时间，若超过这个时间则放弃获取锁。 （3）释放锁的时候，通过UUID判断是不是该锁，若是该锁，则执行delete进行锁释放。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#连接redisredis_client = redis.Redis(host=&quot;localhost&quot;, port=6379, password=password, db=10)#获取一个锁lock_name：锁定名称acquire_time: 客户端等待获取锁的时间time_out: 锁的超时时间def acquire_lock(lock_name, acquire_time=10, time_out=10): &quot;&quot;&quot;获取一个分布式锁&quot;&quot;&quot; identifier = str(uuid.uuid4()) end = time.time() + acquire_time lock = &quot;string:lock:&quot; + lock_name while time.time() &lt; end: if redis_client.setnx(lock, identifier): # 给锁设置超时时间, 防止进程崩溃导致其他进程无法获取锁 redis_client.expire(lock, time_out) return identifier elif not redis_client.ttl(lock): redis_client.expire(lock, time_out) time.sleep(0.001) return False#释放一个锁def release_lock(lock_name, identifier): &quot;&quot;&quot;通用的锁释放函数&quot;&quot;&quot; lock = &quot;string:lock:&quot; + lock_name pip = redis_client.pipeline(True) while True: try: pip.watch(lock) lock_value = redis_client.get(lock) if not lock_value: return True if lock_value.decode() == identifier: pip.multi() pip.delete(lock) pip.execute() return True pip.unwatch() break except redis.excetions.WacthcError: pass return False 1.2.3 基于ZooKeeper的锁机制ZooKeeper是一个为分布式应用提供一致性服务的开源组件，它内部是一个分层的文件系统目录树结构，规定同一个目录下只能有一个唯一文件名。基于ZooKeeper实现分布式锁的步骤如下： （1）创建一个目录mylock； （2）线程A想获取锁就在mylock目录下创建临时顺序节点； （3）获取mylock目录下所有的子节点，然后获取比自己小的兄弟节点，如果不存在，则说明当前线程顺序号最小，获得锁； （4）线程B获取所有节点，判断自己不是最小节点，设置监听比自己次小的节点； （5）线程A处理完，删除自己的节点，线程B监听到变更事件，判断自己是不是最小的节点，如果是则获得锁。 这里推荐一个Apache的开源库Curator，它是一个ZooKeeper客户端，Curator提供的InterProcessMutex是分布式锁的实现，acquire方法用于获取锁，release方法用于释放锁。 优点：具备高可用、可重入、阻塞锁特性，可解决失效死锁问题。 缺点：因为需要频繁的创建和删除节点，性能上不如Redis方式。 1.3 总结上面的三种实现方式，没有在所有场合都是完美的，所以，应根据不同的应用场景选择最适合的实现方式。 在分布式环境中，对资源进行上锁有时候是很重要的，比如抢购某一资源，这时候使用分布式锁就可以很好地控制资源。当然，在具体使用中，还需要考虑很多因素，比如超时时间的选取，获取锁时间的选取对并发量都有很大的影响，上述实现的分布式锁也只是一种简单的实现，主要是一种思想。 参考： https://www.cnblogs.com/liuqingzheng/p/11080501.html 2. Redis双写一致性该问题等同于怎么确保redis和Mysql的数据怎么保证是一致的。 2.1 缓存读取数据过程 访问redis，如果有数据，直接读取redis的数据。 如果redis没有数据，访问mysql，把数据写到redis，访问给用户。 2.2 确保一致性的方法2.2.1 先更新数据库，再更新缓存第一种不适合用于开发场景中，因为： a. 有可能出现脏数据 假设同时有请求A和请求B进行更新操作，那么有可能出现： 线程A更新了数据库 线程B更新了数据库 线程B更新了缓存 线程A更新了缓存 这就出现请求A更新缓存应该比请求B更新缓存早才对，但是因为网络等原因，B却比A更早更新了缓存，这就导致了脏数据。 b.浪费缓存资源 （1）如果你是一个写数据库场景比较多，而读数据场景比较少的业务需求，采用这种方案就会导致，数据压根还没读到，缓存就被频繁的更新，浪费性能。（2）如果你写入数据库的值，并不是直接写入缓存的，而是要经过一系列复杂的计算再写入缓存。那么，每次写入数据库后，都再次计算写入缓存的值，无疑是浪费性能的。显然，删除缓存更为适合。 2.2.2 先删缓存，再更新数据库该方案会导致不一致的原因是。同时有一个请求A进行更新操作，另一个请求B进行查询操作。那么会出现如下情形: 请求A进行写操作，删除缓存 请求B查询发现缓存不存在 请求B去数据库查询得到旧值 请求B将旧值写入缓存 请求A将新值写入数据库 上述情况就会导致不一致的情形出现。而且，如果不采用给缓存设置过期时间策略，该数据永远都是脏数据。 那么，如何解决呢？采用延时双删策略 1234567891011121314/***解决方法的伪代码*/public void write(String key,Object data)&#123; //1、先删除缓存 redis.delKey(key); //2、更新数据库，写入数据 db.updateData(data); //3、休眠1秒 Thread.sleep(1000); //4、再次删除缓存 redis.delKey(key);&#125; 为什么要删除两次呢？为什么要延时呢？延时多久？ 删两次是避免redis是脏数据。延时是等最近一次向redis写数据结束。延时多久看具体情况，例如1ms，1s之类的。 2.2.3 先更新数据库，再删缓存（faceBook用的就是这个）123456789/***解决方法的伪代码*/public void write(String key,Object data)&#123; //1、更新数据库，写入数据 db.updateData(data); //2、删除缓存 redis.delKey(key);&#125; 这种时候还会出现不一致情况吗？会的。 1234567891011121314假设这会有两个请求，一个请求A做查询操作，一个请求B做更新操作，那么会有如下情形产生1）缓存刚好失效2）请求A查询数据库，得一个旧值3）请求B将新值写入数据库4）请求B删除缓存5）请求A将查到的旧值写入缓存发生概率是多少？发生上述情况有一个先天性条件，就是步骤（3）的写数据库操作比步骤（2）的读数据库操作耗时更短，才有可能使得步骤（4）先于步骤（5）。可是，大家想想，数据库的读操作的速度远快于写操作的（不然做读写分离干嘛，做读写分离的意义就是因为读操作比较快，耗资源少），因此步骤（3）耗时比步骤（2）更短，这一情形很难出现。怎么解决？首先，给缓存设有效时间是一种方案。其次，采用策略（2）里给出的异步延时删除策略，保证读请求完成以后，再进行删除操作。 2.3 最佳方案 缓存设置一个有效期先做一个说明，从理论上来说，给缓存设置过期时间，是保证最终一致性的解决方案。这种方案下，我们可以对存入缓存的数据设置过期时间，所有的写操作以数据库为准，对缓存操作只是尽最大努力即可。也就是说如果数据库写成功，缓存更新失败，那么只要到达过期时间，则后面的读请求自然会从数据库中读取新值然后回填缓存。 使用补救队列Redis里的数据总是不过期，但是有个背景更新任务（“定时执行的代码” 或者 “被队列驱动的代码）读取db，把最新的数据塞给Redis。这种做法将Redis看作是“存储”。访问者不知道背后的实际数据源，只知道Redis是唯一可以取的数据的地方。当实际数据源更新时，背景更新任务来将数据更新到Redis。这时还是会存在Redis和实际数据源不一致的问题。如果是定时任务，最长的不一致时长就是更新任务的执行间隔；如果是用类似于队列的方式来更新，那么不一致时间取决于队列产生和消费的延迟。常用的队列（或等价物）有Redis（怎么还是Redis），Kafka，AMQ，RMQ，binglog，log文件，阿里的canal等。 参考https://blog.csdn.net/qq_37493556/article/details/107667185","categories":[{"name":"面试题目","slug":"面试题目","permalink":"http://example.com/categories/%E9%9D%A2%E8%AF%95%E9%A2%98%E7%9B%AE/"}],"tags":[{"name":"redis","slug":"redis","permalink":"http://example.com/tags/redis/"},{"name":"面试题目","slug":"面试题目","permalink":"http://example.com/tags/%E9%9D%A2%E8%AF%95%E9%A2%98%E7%9B%AE/"}]},{"title":"Tampermonkey","slug":"Tampermonkey","date":"2021-12-13T06:47:23.000Z","updated":"2021-12-17T17:18:08.552Z","comments":true,"path":"2021/12/13/Tampermonkey/","link":"","permalink":"http://example.com/2021/12/13/Tampermonkey/","excerpt":"谷歌浏览器很多插件使用方法","text":"Tampermonkey 插件使用你是否还在看广告？无论是优酷、芒果TV、爱奇艺，每一集都得看一次广告你是否还在因为没有会员然后看不到很多东西 本次分享一个插件Tampermonkey,就可以帮你解决这个问题~ 插件安装 选择谷歌浏览器上面...,选择更多工具，选择扩展程序 左上方,选择扩展程序，打开chorme网上商店（需要科学上网） 搜索Tampermonkey，点击然后添加到chorme 在右上角，找到你刚才添加的插件，点击获取新脚本 搜索视频vip，然后任意安装一个插件 插件使用安装完成以后，看一下效果~ 以后看电视就不受vip限制啦~ 知网pdf格式在插件中搜索知网pdf，以后看知网的文章就可以直接下载pdf啦!","categories":[{"name":"教程","slug":"教程","permalink":"http://example.com/categories/%E6%95%99%E7%A8%8B/"}],"tags":[{"name":"chorme","slug":"chorme","permalink":"http://example.com/tags/chorme/"}]},{"title":"Tom's book review","slug":"book-review","date":"2021-12-03T12:05:10.000Z","updated":"2021-12-16T19:00:39.068Z","comments":true,"path":"2021/12/03/book-review/","link":"","permalink":"http://example.com/2021/12/03/book-review/","excerpt":"读书笔记","text":"Tom’s Book Review《网络是怎么连接的》《基金投资指南》","categories":[],"tags":[{"name":"Book","slug":"Book","permalink":"http://example.com/tags/Book/"}]},{"title":"Tom's paper review","slug":"paper-review","date":"2021-12-03T12:05:10.000Z","updated":"2021-12-16T19:00:39.068Z","comments":true,"path":"2021/12/03/paper-review/","link":"","permalink":"http://example.com/2021/12/03/paper-review/","excerpt":"论文笔记","text":"Tom’s Paper Reviewstyle transfer数据集、用途改进点 多尺度特征融合浅层特征和深层特征相融合https://zhuanlan.zhihu.com/p/74710464 残差网络 –&gt; 密集连接网络 改进点文章收集 inception 和 ResNet 相结合 https://m.xzbu.com/8/view-15343830.htm","categories":[],"tags":[{"name":"paper","slug":"paper","permalink":"http://example.com/tags/paper/"}]},{"title":"Tom's video review","slug":"video-review","date":"2021-12-03T12:05:10.000Z","updated":"2021-12-16T19:00:39.068Z","comments":true,"path":"2021/12/03/video-review/","link":"","permalink":"http://example.com/2021/12/03/video-review/","excerpt":"视频笔记","text":"Tom’s Video Review","categories":[],"tags":[{"name":"video","slug":"video","permalink":"http://example.com/tags/video/"}]},{"title":"怎么创建自己的博客？","slug":"create-blog","date":"2021-12-03T10:48:24.000Z","updated":"2021-12-17T17:18:29.296Z","comments":true,"path":"2021/12/03/create-blog/","link":"","permalink":"http://example.com/2021/12/03/create-blog/","excerpt":"在windows下创建自己的博客仓库，并且发布到github，通过访问github来访问博客。","text":"怎么创建自己的博客网站？本教程主要是适合windows下系统的开发和维护。 一、环境准备首先需要安装nodejs还有git 安装nodejs:https://www.cnblogs.com/liuqiyun/p/8133904.html 下载安装git:https://blog.csdn.net/sanxd/article/details/82624127 Hexo下载安装： 1npm install hexo-cli -g 检查是否安装成功： 1234567891011121314151617181920212223242526&gt; node -vv16.13.1&gt; npm -v8.1.2&gt; hexo -vhexo-cli: 4.3.0os: win32 10.0.19042node: 16.13.1v8: 9.4.146.24-node.14uv: 1.42.0zlib: 1.2.11brotli: 1.0.9ares: 1.18.1modules: 93nghttp2: 1.45.1napi: 8llhttp: 6.0.4openssl: 1.1.1l+quiccldr: 39.0icu: 69.1tz: 2021aunicode: 13.0ngtcp2: 0.1.0-DEVnghttp3: 0.1.0-DEV 输入指令出来结果代表环境安装顺利完成！ 二、搭建github仓库新建一个github仓库，仓库名字和用户名字一致。 格式如下：[owener name].github.io 三、生成ssh公钥和私钥，配置到github仓库打开git bash,输入如下所示： 12ssh-keygen -t rsa -C &quot;iszhangyongxin@163.com&quot;ssh-keygen -t rsa -C &quot;your email address&quot; 敲回车4次。 打开 C:\\Users\\你的用户名\\.ssh 文件夹 复制id_rsa.pub文件的内容。 接下来到github上面配置： 访问github 点击setting SSH and GPD keys Add ssh key 测试是否绑定成功打开git bash，输入1ssh -T git@github.com 如果结果为：”Hi xxxxx! You’ve successfully authenticated, but GitHub does not provide shell access.”说明绑定成功。 四、本地跑你的博客 新建一个文件夹（我是在E盘新建blog） 在blog文件夹打开 git bash 输入”hexo init”到这里完成Blog文件夹如下所示： 在git bash 输入 “hexo g”(generate), 再输入 “hexo s”(serve)。 访问 http://localhost:4000/ 就可以看到本地服务的页面了。 想把服务更新到github上面，首先修改你的 _config.yml 文件的deploy字段。 1234deploy: type: git repository: https://github.com/xxxx/xxx.github.io.git branch: main 执行 hexo d,就可以部署成功。 最后，在执行hexo s 或者 hexo d时，先执行hexo clean清理项目。 五、附加 部署完以后一般都是执行 hexo clean| hexo g | hexo s | hexo d","categories":[{"name":"教程","slug":"教程","permalink":"http://example.com/categories/%E6%95%99%E7%A8%8B/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"http://example.com/tags/Hexo/"},{"name":"Fluid","slug":"Fluid","permalink":"http://example.com/tags/Fluid/"}]}],"categories":[{"name":"教程","slug":"教程","permalink":"http://example.com/categories/%E6%95%99%E7%A8%8B/"},{"name":"面试题目","slug":"面试题目","permalink":"http://example.com/categories/%E9%9D%A2%E8%AF%95%E9%A2%98%E7%9B%AE/"}],"tags":[{"name":"MAC","slug":"MAC","permalink":"http://example.com/tags/MAC/"},{"name":"教程","slug":"教程","permalink":"http://example.com/tags/%E6%95%99%E7%A8%8B/"},{"name":"redis","slug":"redis","permalink":"http://example.com/tags/redis/"},{"name":"面试题目","slug":"面试题目","permalink":"http://example.com/tags/%E9%9D%A2%E8%AF%95%E9%A2%98%E7%9B%AE/"},{"name":"chorme","slug":"chorme","permalink":"http://example.com/tags/chorme/"},{"name":"Book","slug":"Book","permalink":"http://example.com/tags/Book/"},{"name":"paper","slug":"paper","permalink":"http://example.com/tags/paper/"},{"name":"video","slug":"video","permalink":"http://example.com/tags/video/"},{"name":"Hexo","slug":"Hexo","permalink":"http://example.com/tags/Hexo/"},{"name":"Fluid","slug":"Fluid","permalink":"http://example.com/tags/Fluid/"}]}