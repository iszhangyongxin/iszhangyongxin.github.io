{"meta":{"title":"Tom的博客","subtitle":"加油加油鸭","description":"某985硕士","author":"Tom","url":"http://example.com","root":"/"},"pages":[],"posts":[{"title":"Tom's redis note","slug":"Redis","date":"2021-12-17T12:05:10.000Z","updated":"2021-12-16T18:45:05.622Z","comments":true,"path":"2021/12/17/Redis/","link":"","permalink":"http://example.com/2021/12/17/Redis/","excerpt":"redis笔记","text":"Redis一、Redis的分布式锁分布式锁是为了实现强一致性，例如 多个用户多个微服务去抢购物车100个限量商品，由于访问的是不同的机器，所以这个100可能是不准确的。 有两个线程（分别叫T1,T2）做的都是同样的事情，拿到一个叫做A的资源，然后对其进行+1操作。由于线程之间是不会互相通信的，于是就有可能出现下面这种情况：T1拿到A，读入内存，此时A值为T；T2拿到A，读入内存，此时A值为T；T1进行+1操作，此时A实际值为T+1；T2进行+1操作，此时A的实际值仍然为T+1; 分布式锁应该具备哪些条件？ 在分析分布式锁的三种实现方式之前，先了解一下分布式锁应该具备哪些条件： 在分布式系统环境下，一个方法在同一时间只能被一个机器的一个线程执行； 高可用的获取锁与释放锁； 高性能的获取锁与释放锁； 具备可重入特性； 具备锁失效机制，防止死锁； 具备非阻塞锁特性，即没有获取到锁将直接返回获取锁失败。 实现分布式锁的三种方式？ 基于数据库实现分布式锁；基于缓存（Redis等）实现分布式锁；基于Zookeeper实现分布式锁； 基于数据库的锁机制 基于数据库的实现方式的核心思想是：在数据库中创建一个表，表中包含方法名等字段，并在方法名字段上创建唯一索引，想要执行某个方法，就使用这个方法名向表中插入数据，成功插入则获取锁，执行完成后删除对应的行数据释放锁。 (1) 创建一个表 123456789DROP TABLE IF EXISTS `method_lock`;CREATE TABLE `method_lock` ( `id` int(11) unsigned NOT NULL AUTO_INCREMENT COMMENT &#x27;主键&#x27;, `method_name` varchar(64) NOT NULL COMMENT &#x27;锁定的方法名&#x27;, `desc` varchar(255) NOT NULL COMMENT &#x27;备注信息&#x27;, `update_time` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP, PRIMARY KEY (`id`), UNIQUE KEY `uidx_method_name` (`method_name`) USING BTREE) ENGINE=InnoDB AUTO_INCREMENT=3 DEFAULT CHARSET=utf8 COMMENT=&#x27;锁定中的方法&#x27;; （2）想要执行某个方法，就使用这个方法名向表中插入数据： INSERT INTO method_lock (method_name, desc) VALUES (‘methodName’, ‘测试的methodName’);因为我们对method_name做了唯一性约束，这里如果有多个请求同时提交到数据库的话，数据库会保证只有一个操作可以成功，那么我们就可以认为操作成功的那个线程获得了该方法的锁，可以执行方法体内容。 （3）成功插入则获取锁，执行完成后删除对应的行数据释放锁： delete from method_lock where method_name =’methodName’; 注意：这只是使用基于数据库的一种方法，使用数据库实现分布式锁还有很多其他的玩法！ 使用基于数据库的这种实现方式很简单，但是对于分布式锁应该具备的条件来说，它有一些问题需要解决及优化： 1、因为是基于数据库实现的，数据库的可用性和性能将直接影响分布式锁的可用性及性能，所以，数据库需要双机部署、数据同步、主备切换； 2、不具备可重入的特性，因为同一个线程在释放锁之前，行数据一直存在，无法再次成功插入数据，所以，需要在表中新增一列，用于记录当前获取到锁的机器和线程信息，在再次获取锁的时候，先查询表中机器和线程信息是否和当前机器和线程相同，若相同则直接获取锁； 3、没有锁失效机制，因为有可能出现成功插入数据后，服务器宕机了，对应的数据没有被删除，当服务恢复后一直获取不到锁，所以，需要在表中新增一列，用于记录失效时间，并且需要有定时任务清除这些失效的数据； 4、不具备阻塞锁特性，获取不到锁直接返回失败，所以需要优化获取逻辑，循环多次去获取。 5、在实施的过程中会遇到各种不同的问题，为了解决这些问题，实现方式将会越来越复杂；依赖数据库需要一定的资源开销，性能问题需要考虑。 基于redis的锁机制 1、选用Redis实现分布式锁原因： （1）Redis有很高的性能；（2）Redis命令对此支持较好，实现起来比较方便 2、使用命令介绍： （1）SETNX SETNX key val：当且仅当key不存在时，set一个key为val的字符串，返回1；若key存在，则什么都不做，返回0。 （2）expire expire key timeout：为key设置一个超时时间，单位为second，超过这个时间锁会自动释放，避免死锁。 （3）delete delete key：删除key 在使用Redis实现分布式锁的时候，主要就会使用到这三个命令。 3、实现思想： （1）获取锁的时候，使用setnx加锁，并使用expire命令为锁添加一个超时时间，超过该时间则自动释放锁，锁的value值为一个随机生成的UUID，通过此在释放锁的时候进行判断。 （2）获取锁的时候还设置一个获取的超时时间，若超过这个时间则放弃获取锁。 （3）释放锁的时候，通过UUID判断是不是该锁，若是该锁，则执行delete进行锁释放。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#连接redisredis_client = redis.Redis(host=&quot;localhost&quot;, port=6379, password=password, db=10)#获取一个锁lock_name：锁定名称acquire_time: 客户端等待获取锁的时间time_out: 锁的超时时间def acquire_lock(lock_name, acquire_time=10, time_out=10): &quot;&quot;&quot;获取一个分布式锁&quot;&quot;&quot; identifier = str(uuid.uuid4()) end = time.time() + acquire_time lock = &quot;string:lock:&quot; + lock_name while time.time() &lt; end: if redis_client.setnx(lock, identifier): # 给锁设置超时时间, 防止进程崩溃导致其他进程无法获取锁 redis_client.expire(lock, time_out) return identifier elif not redis_client.ttl(lock): redis_client.expire(lock, time_out) time.sleep(0.001) return False#释放一个锁def release_lock(lock_name, identifier): &quot;&quot;&quot;通用的锁释放函数&quot;&quot;&quot; lock = &quot;string:lock:&quot; + lock_name pip = redis_client.pipeline(True) while True: try: pip.watch(lock) lock_value = redis_client.get(lock) if not lock_value: return True if lock_value.decode() == identifier: pip.multi() pip.delete(lock) pip.execute() return True pip.unwatch() break except redis.excetions.WacthcError: pass return False 基于ZooKeeper的锁机制 ZooKeeper是一个为分布式应用提供一致性服务的开源组件，它内部是一个分层的文件系统目录树结构，规定同一个目录下只能有一个唯一文件名。基于ZooKeeper实现分布式锁的步骤如下： （1）创建一个目录mylock；（2）线程A想获取锁就在mylock目录下创建临时顺序节点；（3）获取mylock目录下所有的子节点，然后获取比自己小的兄弟节点，如果不存在，则说明当前线程顺序号最小，获得锁；（4）线程B获取所有节点，判断自己不是最小节点，设置监听比自己次小的节点；（5）线程A处理完，删除自己的节点，线程B监听到变更事件，判断自己是不是最小的节点，如果是则获得锁。 这里推荐一个Apache的开源库Curator，它是一个ZooKeeper客户端，Curator提供的InterProcessMutex是分布式锁的实现，acquire方法用于获取锁，release方法用于释放锁。 优点：具备高可用、可重入、阻塞锁特性，可解决失效死锁问题。 缺点：因为需要频繁的创建和删除节点，性能上不如Redis方式。 总结 上面的三种实现方式，没有在所有场合都是完美的，所以，应根据不同的应用场景选择最适合的实现方式。 在分布式环境中，对资源进行上锁有时候是很重要的，比如抢购某一资源，这时候使用分布式锁就可以很好地控制资源。当然，在具体使用中，还需要考虑很多因素，比如超时时间的选取，获取锁时间的选取对并发量都有很大的影响，上述实现的分布式锁也只是一种简单的实现，主要是一种思想。 参考： https://www.cnblogs.com/liuqingzheng/p/11080501.html","categories":[],"tags":[{"name":"redis","slug":"redis","permalink":"http://example.com/tags/redis/"}]},{"title":"Tampermonkey","slug":"Tampermonkey","date":"2019-12-13T06:47:23.000Z","updated":"2021-12-16T14:14:19.104Z","comments":true,"path":"2019/12/13/Tampermonkey/","link":"","permalink":"http://example.com/2019/12/13/Tampermonkey/","excerpt":"谷歌插件","text":"Tampermonkey 插件使用你是否还在看广告？无论是优酷、芒果TV、爱奇艺，每一集都得看一次广告你是否还在因为没有会员然后看不到很多东西 本次分享一个插件Tampermonkey,就可以帮你解决这个问题~ 插件安装 选择谷歌浏览器上面...,选择更多工具，选择扩展程序 左上方,选择扩展程序，打开chorme网上商店（需要科学上网） 搜索Tampermonkey，点击然后添加到chorme 在右上角，找到你刚才添加的插件，点击获取新脚本 搜索视频vip，然后任意安装一个插件 插件使用安装完成以后，看一下效果~ 以后看电视就不受vip限制啦~ 知网pdf格式在插件中搜索知网pdf，以后看知网的文章就可以直接下载pdf啦!","categories":[],"tags":[{"name":"chorme","slug":"chorme","permalink":"http://example.com/tags/chorme/"}]},{"title":"Tom's book review","slug":"book-review","date":"2019-12-03T12:05:10.000Z","updated":"2021-12-03T12:43:52.000Z","comments":true,"path":"2019/12/03/book-review/","link":"","permalink":"http://example.com/2019/12/03/book-review/","excerpt":"读书笔记","text":"Tom’s Book Review《网络是怎么连接的》《基金投资指南》","categories":[],"tags":[{"name":"Book","slug":"Book","permalink":"http://example.com/tags/Book/"}]},{"title":"Tom's paper review","slug":"paper-review","date":"2019-12-03T12:05:10.000Z","updated":"2021-12-05T11:45:42.000Z","comments":true,"path":"2019/12/03/paper-review/","link":"","permalink":"http://example.com/2019/12/03/paper-review/","excerpt":"论文笔记","text":"Tom’s Paper Reviewstyle transfer数据集、用途改进点 多尺度特征融合浅层特征和深层特征相融合https://zhuanlan.zhihu.com/p/74710464 残差网络 –&gt; 密集连接网络 改进点文章收集 inception 和 ResNet 相结合 https://m.xzbu.com/8/view-15343830.htm","categories":[],"tags":[{"name":"paper","slug":"paper","permalink":"http://example.com/tags/paper/"}]},{"title":"Tom's video review","slug":"video-review","date":"2019-12-03T12:05:10.000Z","updated":"2021-12-03T12:43:56.000Z","comments":true,"path":"2019/12/03/video-review/","link":"","permalink":"http://example.com/2019/12/03/video-review/","excerpt":"视频笔记","text":"Tom’s Video Review","categories":[],"tags":[{"name":"video","slug":"video","permalink":"http://example.com/tags/video/"}]},{"title":"怎么创建自己的博客？","slug":"create-blog","date":"2019-12-03T10:48:24.000Z","updated":"2021-12-05T07:32:38.000Z","comments":true,"path":"2019/12/03/create-blog/","link":"","permalink":"http://example.com/2019/12/03/create-blog/","excerpt":"在windows下创建自己的博客仓库，并且发布到github，通过访问github来访问博客。","text":"怎么创建自己的博客网站？本教程主要是适合windows下系统的开发和维护。 一、环境准备首先需要安装nodejs还有git 安装nodejs:https://www.cnblogs.com/liuqiyun/p/8133904.html 下载安装git:https://blog.csdn.net/sanxd/article/details/82624127 Hexo下载安装： 1npm install hexo-cli -g 检查是否安装成功： 1234567891011121314151617181920212223242526&gt; node -vv16.13.1&gt; npm -v8.1.2&gt; hexo -vhexo-cli: 4.3.0os: win32 10.0.19042node: 16.13.1v8: 9.4.146.24-node.14uv: 1.42.0zlib: 1.2.11brotli: 1.0.9ares: 1.18.1modules: 93nghttp2: 1.45.1napi: 8llhttp: 6.0.4openssl: 1.1.1l+quiccldr: 39.0icu: 69.1tz: 2021aunicode: 13.0ngtcp2: 0.1.0-DEVnghttp3: 0.1.0-DEV 输入指令出来结果代表环境安装顺利完成！ 二、搭建github仓库新建一个github仓库，仓库名字和用户名字一致。 格式如下：[owener name].github.io 三、生成ssh公钥和私钥，配置到github仓库打开git bash,输入如下所示： 12ssh-keygen -t rsa -C &quot;iszhangyongxin@163.com&quot;ssh-keygen -t rsa -C &quot;your email address&quot; 敲回车4次。 打开 C:\\Users\\你的用户名\\.ssh 文件夹 复制id_rsa.pub文件的内容。 接下来到github上面配置： 访问github 点击setting SSH and GPD keys Add ssh key 测试是否绑定成功打开git bash，输入1ssh -T git@github.com 如果结果为：”Hi xxxxx! You’ve successfully authenticated, but GitHub does not provide shell access.”说明绑定成功。 四、本地跑你的博客 新建一个文件夹（我是在E盘新建blog） 在blog文件夹打开 git bash 输入”hexo init”到这里完成Blog文件夹如下所示： 在git bash 输入 “hexo g”(generate), 再输入 “hexo s”(serve)。 访问 http://localhost:4000/ 就可以看到本地服务的页面了。 想把服务更新到github上面，首先修改你的 _config.yml 文件的deploy字段。 1234deploy: type: git repository: https://github.com/xxxx/xxx.github.io.git branch: main 执行 hexo d,就可以部署成功。 最后，在执行hexo s 或者 hexo d时，先执行hexo clean清理项目。 五、附加 部署完以后一般都是执行 hexo clean| hexo g | hexo s | hexo d","categories":[],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"http://example.com/tags/Hexo/"},{"name":"Fluid","slug":"Fluid","permalink":"http://example.com/tags/Fluid/"}]}],"categories":[],"tags":[{"name":"redis","slug":"redis","permalink":"http://example.com/tags/redis/"},{"name":"chorme","slug":"chorme","permalink":"http://example.com/tags/chorme/"},{"name":"Book","slug":"Book","permalink":"http://example.com/tags/Book/"},{"name":"paper","slug":"paper","permalink":"http://example.com/tags/paper/"},{"name":"video","slug":"video","permalink":"http://example.com/tags/video/"},{"name":"Hexo","slug":"Hexo","permalink":"http://example.com/tags/Hexo/"},{"name":"Fluid","slug":"Fluid","permalink":"http://example.com/tags/Fluid/"}]}