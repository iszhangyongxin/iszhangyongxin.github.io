{"meta":{"title":"Tom的博客","subtitle":"加油加油鸭","description":"某985硕士","author":"Tom","url":"http://example.com","root":"/"},"pages":[{"title":"about","date":"2021-12-17T15:45:41.000Z","updated":"2021-12-18T18:40:53.301Z","comments":false,"path":"about/index.html","permalink":"http://example.com/about/index.html","excerpt":"","text":"关于我某小小程序员，想要成长！ 网页变动 2021.12.19 增加计算机网络的知识点。 进行了总结了一下，发现其实以前对问题的回答没有很好。 尽量以最简单的语言去表达最正确的知识点。 2021.12.18 增加数据库、计算机网络、操作系统的md文件，还没有想好写啥呢。 增加MAC使用技巧，解决了git每次都要密码的问题，还有git 速度慢的问题也解决了。 2021.12.17 想要建立系列文章，以后尽量以【面试题目】来作为文章标题，然后尝试创建专栏。 改动：redis 双写一致性 和 redis分布式锁。 donors 社会闲散人员 - momo 黄*豪 邓*得 杨*媛 李*昂 感谢以上名单的人员，排名不分先后！ 【彩蛋-我的学姐】我的学姐是一个非常独特的女生，角度清奇，能力一流～很多东西都是她教我的，基础也很好！学姐加油鸭！ 2021-12-18 凌晨12:18 访问量 【彩蛋-我的好朋友们】宁蓉萌乐 蔬菜家族 2021-12-18 凌晨01:25 2021.12.19 总访问量 709 次 总访客数 247 人 2021.12.18 总访问量 644 次 总访客数 231 人 2021.12.17 总访问量 616 次 总访客数 228 人"}],"posts":[{"title":"【英语】--- 背单词","slug":"英语","date":"2021-12-23T09:00:00.000Z","updated":"2021-12-27T09:17:15.240Z","comments":true,"path":"2021/12/23/英语/","link":"","permalink":"http://example.com/2021/12/23/%E8%8B%B1%E8%AF%AD/","excerpt":"英文背单词，多背一个是一个","text":"星期英文单词Monday 星期一 （忙的day） TuesDay 星期二 WednesDay 星期二 ThursDay 星期四 FriDay 星期五 （福来的一天） SaturDay 星期六 （洒脱的一天） SunDay 星期日 （出太阳🌞的一天） 谐音梗 第一期charm 魅力 （差吗，我的魅力差吗） nasty 肮脏的，恶心的，令人厌恶的 （那些涕） postman 邮递员，快递员 （跑死他们） custman 海关人员 （卡死他们） economy 经济 （依靠农民） adult 成年 （儿子大了） landlord 地主 （懒得劳动） pregnat 地主 （扑来个男的） accomplish 实现 （尔康不能死 尔康死了，还珠格格就结束了） bonus 奖金，红利 （不能死，我还有奖金呢） collection 快来个神 （收集） compete 看屁的，看屁的比赛 （比赛） 谐音梗 第二期【彩蛋】学姐说催更 我就来更新第二期啦～ 【格式】 单词 解释 （谐音，谐音解释） kettle 水壶 （开透，水壶水开透啦） lamb 羔羊，小羊🐑 （烂不，这只小羊煮得烂不？） gorgeous 华丽的，绚丽的 （高级死，高级死的一半就华丽） grace 优雅的 （贵死，贵死一般是优雅的） hen 母鸡 （恨，母鸡恨你吃它鸡蛋🥚） installment 分期付款 （因事躲门，分期付款没还被堵门🚪了，躲在门后） jail 监狱 （煎熬，监狱很骄傲） jeans 牛仔裤 （紧死，牛仔裤👖紧死了） jewel 宝石 （珠哦，这个珠哦是宝石💎） jungle 丛林 （浆果🍓，这个丛林有很多浆果）","categories":[{"name":"英语","slug":"英语","permalink":"http://example.com/categories/%E8%8B%B1%E8%AF%AD/"}],"tags":[{"name":"英语","slug":"英语","permalink":"http://example.com/tags/%E8%8B%B1%E8%AF%AD/"},{"name":"谐音","slug":"谐音","permalink":"http://example.com/tags/%E8%B0%90%E9%9F%B3/"}]},{"title":"【MAC】使用技巧","slug":"MAC使用","date":"2021-12-17T16:01:33.000Z","updated":"2021-12-17T18:04:36.811Z","comments":true,"path":"2021/12/18/MAC使用/","link":"","permalink":"http://example.com/2021/12/18/MAC%E4%BD%BF%E7%94%A8/","excerpt":"新拿到一个新的MAC，你该怎么办？","text":"1. 开发 iTerm2，非常好用的控制台程序 oh my zsh git 2. 使用 微信 音乐播放软件-酷狗/网易云等 谷歌浏览器 - 油猴助手（太多好用插件了） 3. 一些链接分享3.1 我开了vpn了，git网页能进去，但是为什么我的git push 或者 git clone 都特别慢 原因：没有设置代理,为什么慢是因为你没有使用你的vpn，还是原来的网络环境解决方法： vim ~/.gitconfig 检查一下是否设置了你vpn的代理然后设置代理 12设置代理方法即可解决(请自行查找你的vpn的http代理端口)git config --global http.proxy &quot;localhost:port&quot; 怎么取消？ 1git config --global --unset http.proxy 参考 https://www.jianshu.com/p/471aeba64724 3.2 git push 每次都要我输入用户名和密码输入命令 git config --global credential.helper store 之后再操作git输入一次用户名、密码，后续不需要再次输入了 push你的代码 (git push), 这时会让你输入用户名和密码, 这一步输入的用户名密码会被记住,下次再push代码时就不用输入用户名密码 ! 这一步会在用户目录下生成文件.git-credential记录用户名密码的信息。 参考 https://blog.csdn.net/Forcezs/article/details/84136902","categories":[{"name":"教程","slug":"教程","permalink":"http://example.com/categories/%E6%95%99%E7%A8%8B/"}],"tags":[{"name":"MAC","slug":"MAC","permalink":"http://example.com/tags/MAC/"},{"name":"教程","slug":"教程","permalink":"http://example.com/tags/%E6%95%99%E7%A8%8B/"}]},{"title":"【面试题目】---redis","slug":"Redis","date":"2021-12-17T12:05:10.000Z","updated":"2021-12-17T16:54:36.383Z","comments":true,"path":"2021/12/17/Redis/","link":"","permalink":"http://example.com/2021/12/17/Redis/","excerpt":"redis数据类型，双写一致性，分布式锁等。","text":"1. 分布式锁分布式锁是为了实现强一致性，例如 多个用户多个微服务去抢购物车100个限量商品，由于访问的是不同的机器，所以这个100可能是不准确的。 有两个线程（分别叫T1,T2）做的都是同样的事情，拿到一个叫做A的资源，然后对其进行+1操作。由于线程之间是不会互相通信的，于是就有可能出现下面这种情况：T1拿到A，读入内存，此时A值为T；T2拿到A，读入内存，此时A值为T；T1进行+1操作，此时A实际值为T+1；T2进行+1操作，此时A的实际值仍然为T+1; 1.1 分布式锁应该具备哪些条件？在分析分布式锁的三种实现方式之前，先了解一下分布式锁应该具备哪些条件： 在分布式系统环境下，一个方法在同一时间只能被一个机器的一个线程执行； 高可用的获取锁与释放锁； 高性能的获取锁与释放锁； 具备可重入特性； 具备锁失效机制，防止死锁； 具备非阻塞锁特性，即没有获取到锁将直接返回获取锁失败。 1.2 实现分布式锁的三种方式？ 基于数据库实现分布式锁；基于缓存（Redis等）实现分布式锁；基于Zookeeper实现分布式锁； 1.2.1 基于数据库的锁机制基于数据库的实现方式的核心思想是：在数据库中创建一个表，表中包含方法名等字段，并在方法名字段上创建唯一索引，想要执行某个方法，就使用这个方法名向表中插入数据，成功插入则获取锁，执行完成后删除对应的行数据释放锁。 (1) 创建一个表 123456789DROP TABLE IF EXISTS `method_lock`;CREATE TABLE `method_lock` ( `id` int(11) unsigned NOT NULL AUTO_INCREMENT COMMENT &#x27;主键&#x27;, `method_name` varchar(64) NOT NULL COMMENT &#x27;锁定的方法名&#x27;, `desc` varchar(255) NOT NULL COMMENT &#x27;备注信息&#x27;, `update_time` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP, PRIMARY KEY (`id`), UNIQUE KEY `uidx_method_name` (`method_name`) USING BTREE) ENGINE=InnoDB AUTO_INCREMENT=3 DEFAULT CHARSET=utf8 COMMENT=&#x27;锁定中的方法&#x27;; （2）想要执行某个方法，就使用这个方法名向表中插入数据： INSERT INTO method_lock (method_name, desc) VALUES (‘methodName’, ‘测试的methodName’);因为我们对method_name做了唯一性约束，这里如果有多个请求同时提交到数据库的话，数据库会保证只有一个操作可以成功，那么我们就可以认为操作成功的那个线程获得了该方法的锁，可以执行方法体内容。 （3）成功插入则获取锁，执行完成后删除对应的行数据释放锁： delete from method_lock where method_name =’methodName’; 注意：这只是使用基于数据库的一种方法，使用数据库实现分布式锁还有很多其他的玩法！ 使用基于数据库的这种实现方式很简单，但是对于分布式锁应该具备的条件来说，它有一些问题需要解决及优化： 1、因为是基于数据库实现的，数据库的可用性和性能将直接影响分布式锁的可用性及性能，所以，数据库需要双机部署、数据同步、主备切换； 2、不具备可重入的特性，因为同一个线程在释放锁之前，行数据一直存在，无法再次成功插入数据，所以，需要在表中新增一列，用于记录当前获取到锁的机器和线程信息，在再次获取锁的时候，先查询表中机器和线程信息是否和当前机器和线程相同，若相同则直接获取锁； 3、没有锁失效机制，因为有可能出现成功插入数据后，服务器宕机了，对应的数据没有被删除，当服务恢复后一直获取不到锁，所以，需要在表中新增一列，用于记录失效时间，并且需要有定时任务清除这些失效的数据； 4、不具备阻塞锁特性，获取不到锁直接返回失败，所以需要优化获取逻辑，循环多次去获取。 5、在实施的过程中会遇到各种不同的问题，为了解决这些问题，实现方式将会越来越复杂；依赖数据库需要一定的资源开销，性能问题需要考虑。 1.2.2 基于redis的锁机制1、选用Redis实现分布式锁原因： （1）Redis有很高的性能；（2）Redis命令对此支持较好，实现起来比较方便 2、使用命令介绍： （1）SETNX SETNX key val：当且仅当key不存在时，set一个key为val的字符串，返回1；若key存在，则什么都不做，返回0。 （2）expire expire key timeout：为key设置一个超时时间，单位为second，超过这个时间锁会自动释放，避免死锁。 （3）delete delete key：删除key 在使用Redis实现分布式锁的时候，主要就会使用到这三个命令。 3、实现思想： （1）获取锁的时候，使用setnx加锁，并使用expire命令为锁添加一个超时时间，超过该时间则自动释放锁，锁的value值为一个随机生成的UUID，通过此在释放锁的时候进行判断。 （2）获取锁的时候还设置一个获取的超时时间，若超过这个时间则放弃获取锁。 （3）释放锁的时候，通过UUID判断是不是该锁，若是该锁，则执行delete进行锁释放。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#连接redisredis_client = redis.Redis(host=&quot;localhost&quot;, port=6379, password=password, db=10)#获取一个锁lock_name：锁定名称acquire_time: 客户端等待获取锁的时间time_out: 锁的超时时间def acquire_lock(lock_name, acquire_time=10, time_out=10): &quot;&quot;&quot;获取一个分布式锁&quot;&quot;&quot; identifier = str(uuid.uuid4()) end = time.time() + acquire_time lock = &quot;string:lock:&quot; + lock_name while time.time() &lt; end: if redis_client.setnx(lock, identifier): # 给锁设置超时时间, 防止进程崩溃导致其他进程无法获取锁 redis_client.expire(lock, time_out) return identifier elif not redis_client.ttl(lock): redis_client.expire(lock, time_out) time.sleep(0.001) return False#释放一个锁def release_lock(lock_name, identifier): &quot;&quot;&quot;通用的锁释放函数&quot;&quot;&quot; lock = &quot;string:lock:&quot; + lock_name pip = redis_client.pipeline(True) while True: try: pip.watch(lock) lock_value = redis_client.get(lock) if not lock_value: return True if lock_value.decode() == identifier: pip.multi() pip.delete(lock) pip.execute() return True pip.unwatch() break except redis.excetions.WacthcError: pass return False 1.2.3 基于ZooKeeper的锁机制ZooKeeper是一个为分布式应用提供一致性服务的开源组件，它内部是一个分层的文件系统目录树结构，规定同一个目录下只能有一个唯一文件名。基于ZooKeeper实现分布式锁的步骤如下： （1）创建一个目录mylock； （2）线程A想获取锁就在mylock目录下创建临时顺序节点； （3）获取mylock目录下所有的子节点，然后获取比自己小的兄弟节点，如果不存在，则说明当前线程顺序号最小，获得锁； （4）线程B获取所有节点，判断自己不是最小节点，设置监听比自己次小的节点； （5）线程A处理完，删除自己的节点，线程B监听到变更事件，判断自己是不是最小的节点，如果是则获得锁。 这里推荐一个Apache的开源库Curator，它是一个ZooKeeper客户端，Curator提供的InterProcessMutex是分布式锁的实现，acquire方法用于获取锁，release方法用于释放锁。 优点：具备高可用、可重入、阻塞锁特性，可解决失效死锁问题。 缺点：因为需要频繁的创建和删除节点，性能上不如Redis方式。 1.3 总结上面的三种实现方式，没有在所有场合都是完美的，所以，应根据不同的应用场景选择最适合的实现方式。 在分布式环境中，对资源进行上锁有时候是很重要的，比如抢购某一资源，这时候使用分布式锁就可以很好地控制资源。当然，在具体使用中，还需要考虑很多因素，比如超时时间的选取，获取锁时间的选取对并发量都有很大的影响，上述实现的分布式锁也只是一种简单的实现，主要是一种思想。 参考： https://www.cnblogs.com/liuqingzheng/p/11080501.html 2. Redis双写一致性该问题等同于怎么确保redis和Mysql的数据怎么保证是一致的。 2.1 缓存读取数据过程 访问redis，如果有数据，直接读取redis的数据。 如果redis没有数据，访问mysql，把数据写到redis，访问给用户。 2.2 确保一致性的方法2.2.1 先更新数据库，再更新缓存第一种不适合用于开发场景中，因为： a. 有可能出现脏数据 假设同时有请求A和请求B进行更新操作，那么有可能出现： 线程A更新了数据库 线程B更新了数据库 线程B更新了缓存 线程A更新了缓存 这就出现请求A更新缓存应该比请求B更新缓存早才对，但是因为网络等原因，B却比A更早更新了缓存，这就导致了脏数据。 b.浪费缓存资源 （1）如果你是一个写数据库场景比较多，而读数据场景比较少的业务需求，采用这种方案就会导致，数据压根还没读到，缓存就被频繁的更新，浪费性能。（2）如果你写入数据库的值，并不是直接写入缓存的，而是要经过一系列复杂的计算再写入缓存。那么，每次写入数据库后，都再次计算写入缓存的值，无疑是浪费性能的。显然，删除缓存更为适合。 2.2.2 先删缓存，再更新数据库该方案会导致不一致的原因是。同时有一个请求A进行更新操作，另一个请求B进行查询操作。那么会出现如下情形: 请求A进行写操作，删除缓存 请求B查询发现缓存不存在 请求B去数据库查询得到旧值 请求B将旧值写入缓存 请求A将新值写入数据库 上述情况就会导致不一致的情形出现。而且，如果不采用给缓存设置过期时间策略，该数据永远都是脏数据。 那么，如何解决呢？采用延时双删策略 1234567891011121314/***解决方法的伪代码*/public void write(String key,Object data)&#123; //1、先删除缓存 redis.delKey(key); //2、更新数据库，写入数据 db.updateData(data); //3、休眠1秒 Thread.sleep(1000); //4、再次删除缓存 redis.delKey(key);&#125; 为什么要删除两次呢？为什么要延时呢？延时多久？ 删两次是避免redis是脏数据。延时是等最近一次向redis写数据结束。延时多久看具体情况，例如1ms，1s之类的。 2.2.3 先更新数据库，再删缓存（faceBook用的就是这个）123456789/***解决方法的伪代码*/public void write(String key,Object data)&#123; //1、更新数据库，写入数据 db.updateData(data); //2、删除缓存 redis.delKey(key);&#125; 这种时候还会出现不一致情况吗？会的。 1234567891011121314假设这会有两个请求，一个请求A做查询操作，一个请求B做更新操作，那么会有如下情形产生1）缓存刚好失效2）请求A查询数据库，得一个旧值3）请求B将新值写入数据库4）请求B删除缓存5）请求A将查到的旧值写入缓存发生概率是多少？发生上述情况有一个先天性条件，就是步骤（3）的写数据库操作比步骤（2）的读数据库操作耗时更短，才有可能使得步骤（4）先于步骤（5）。可是，大家想想，数据库的读操作的速度远快于写操作的（不然做读写分离干嘛，做读写分离的意义就是因为读操作比较快，耗资源少），因此步骤（3）耗时比步骤（2）更短，这一情形很难出现。怎么解决？首先，给缓存设有效时间是一种方案。其次，采用策略（2）里给出的异步延时删除策略，保证读请求完成以后，再进行删除操作。 2.3 最佳方案 缓存设置一个有效期先做一个说明，从理论上来说，给缓存设置过期时间，是保证最终一致性的解决方案。这种方案下，我们可以对存入缓存的数据设置过期时间，所有的写操作以数据库为准，对缓存操作只是尽最大努力即可。也就是说如果数据库写成功，缓存更新失败，那么只要到达过期时间，则后面的读请求自然会从数据库中读取新值然后回填缓存。 使用补救队列Redis里的数据总是不过期，但是有个背景更新任务（“定时执行的代码” 或者 “被队列驱动的代码）读取db，把最新的数据塞给Redis。这种做法将Redis看作是“存储”。访问者不知道背后的实际数据源，只知道Redis是唯一可以取的数据的地方。当实际数据源更新时，背景更新任务来将数据更新到Redis。这时还是会存在Redis和实际数据源不一致的问题。如果是定时任务，最长的不一致时长就是更新任务的执行间隔；如果是用类似于队列的方式来更新，那么不一致时间取决于队列产生和消费的延迟。常用的队列（或等价物）有Redis（怎么还是Redis），Kafka，AMQ，RMQ，binglog，log文件，阿里的canal等。 参考https://blog.csdn.net/qq_37493556/article/details/107667185","categories":[{"name":"面试题目","slug":"面试题目","permalink":"http://example.com/categories/%E9%9D%A2%E8%AF%95%E9%A2%98%E7%9B%AE/"}],"tags":[{"name":"redis","slug":"redis","permalink":"http://example.com/tags/redis/"},{"name":"面试题目","slug":"面试题目","permalink":"http://example.com/tags/%E9%9D%A2%E8%AF%95%E9%A2%98%E7%9B%AE/"}]},{"title":"【面试题目】---操作系统","slug":"操作系统","date":"2021-12-17T12:05:10.000Z","updated":"2021-12-17T18:14:36.707Z","comments":true,"path":"2021/12/17/操作系统/","link":"","permalink":"http://example.com/2021/12/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/","excerpt":"进程、线程、cpu、内存","text":"","categories":[{"name":"面试题目","slug":"面试题目","permalink":"http://example.com/categories/%E9%9D%A2%E8%AF%95%E9%A2%98%E7%9B%AE/"}],"tags":[{"name":"面试题目","slug":"面试题目","permalink":"http://example.com/tags/%E9%9D%A2%E8%AF%95%E9%A2%98%E7%9B%AE/"},{"name":"操作系统","slug":"操作系统","permalink":"http://example.com/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}]},{"title":"【面试题目】---数据库","slug":"数据库","date":"2021-12-17T12:05:10.000Z","updated":"2021-12-17T18:45:31.192Z","comments":true,"path":"2021/12/17/数据库/","link":"","permalink":"http://example.com/2021/12/17/%E6%95%B0%E6%8D%AE%E5%BA%93/","excerpt":"MYSQL索引，事物，锁等。","text":"一、事务二、索引2.1 MYSQL的存储引擎？2.2 什么是索引？常见的索引？优缺点？","categories":[{"name":"面试题目","slug":"面试题目","permalink":"http://example.com/categories/%E9%9D%A2%E8%AF%95%E9%A2%98%E7%9B%AE/"}],"tags":[{"name":"面试题目","slug":"面试题目","permalink":"http://example.com/tags/%E9%9D%A2%E8%AF%95%E9%A2%98%E7%9B%AE/"},{"name":"数据库","slug":"数据库","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"}]},{"title":"【面试题目】---计算机网络","slug":"计算机网络1","date":"2021-12-17T12:05:10.000Z","updated":"2021-12-22T18:31:15.322Z","comments":true,"path":"2021/12/17/计算机网络1/","link":"","permalink":"http://example.com/2021/12/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C1/","excerpt":"三次握手，四次挥手？HTTP/HTTPS？尽量以最简单的语言去表达最正确的知识点。","text":"一、TCP与UDP1.1 TCP与UDP的区别？🔥🔥🔥 总结：面向连接、可靠、一对一、传输对象、传输效率 TCP面向连接;UDP是无连接的。 TCP提供可靠的服务。也就是说，通过TCP连接传送的数据，无差错，不丢失，不重复，且按序到达;UDP尽最大努力交付，即不保证可靠交付。 TCP面向字节流，UDP是面向报文的。 每一条TCP连接只能是点到点的;UDP支持一对一，一对多，多对一和多对多的交互通信。 TCP首部开销20字节;UDP的首部开销小，只有8个字节。 UDP效率比TCP效率高，因为不需要三次握手，四次挥手。 各自的应用场景/协议？ 协议 名称 默认端口 底层协议 HTTP 超文本传输协议 80 TCP HTTPS 超文本传输安全协议 443 TCP Telnet 远程登录服务的标准协议 23 TCP FTP 文件传输协议 20传输和21连接 TCP TFTP 简单文件传输协议 69 UDP SMTP 简单邮件传输协议（发送用） 25 TCP POP 邮局协议（接收用） 110 TCP DNS 域名解析服务 53 服务器间进行域传输的时候用TCP客户端查询DNS服务器时用 UDP 1.2 三次握手和四次挥手 🔥🔥🔥1.2.1 三次握手 为什么握手是三次，两次行不行，四次行不行 总结：三次握手是为了让双方都知道对方的发送和接受能力是正常的。然后两次不行，因为之前结束的请求可能再次出现，四次又太浪费了，没必要。 第一次握手：服务器知道客户端发送能力正常。 第二次握手：客户端知道服务器 接收能力｜发送能力 都正常。 第三次握手：服务器知道客户端 接收能力｜发送能力 都正常。 试想如果是用两次握手，则会出现下面这种情况： 如客户端发出连接请求，但因连接请求报文丢失而未收到确认，于是客户端再重传一次连接请求。后来收到了确认，建立了连接。数据传输完毕后，就释放了连接，客户端共发出了两个连接请求报文段，其中第一个丢失，第二个到达了服务端。 但是第一个丢失的报文段只是在某些网络结点长时间滞留了，延误到连接释放以后的某个时间才到达服务端，此时服务端误认为客户端又发出一次新的连接请求，于是就向客户端发出确认报文段，同意建立连接，不采用三次握手，只要服务端发出确认，就建立新的连接了，此时客户端忽略服务端发来的确认，也不发送数据，则服务端一致等待客户端发送数据，浪费资源。 半连接队列，SYN攻击，洪泛攻击、DDos攻击半连接 服务器第一次收到客户端的 SYN 之后，就会处于 SYN_RCVD 状态，此时双方还没有完全建立其连接，服务器会把此种状态下请求连接放在一个队列里，我们把这种队列称之为半连接队列。当然还有一个全连接队列，就是已经完成三次握手，建立起连接的就会放在全连接队列中。 SYN攻击、DDos攻击 DDos攻击 客户端向服务端发送请求链接数据包，服务端向客户端发送确认数据包，客户端不向服务端发送确认数据包，服务器一直等待来自客户端的确认没有彻底根治的办法，除非不使用TCPDDos 预防： 限制同时打开SYN半链接的数目 缩短SYN半链接的Time out 时间 关闭不必要的服务 SYN攻击 服务器端的资源分配是在二次握手时分配的，而客户端的资源是在完成三次握手时分配的，所以服务器容易受到SYN洪泛攻击。SYN攻击就是Client在短时间内伪造大量不存在的IP地址，并向Server不断地发送SYN包，Server则回复确认包，并等待Client确认，由于源地址不存在，因此Server需要不断重发直至超时，这些伪造的SYN包将长时间占用未连接队列，导致正常的SYN请求因为队列满而被丢弃，从而引起网络拥塞甚至系统瘫痪。SYN 攻击是一种典型的 DoS/DDoS 攻击。 检测 SYN 攻击非常的方便，当你在服务器上看到大量的半连接状态时，特别是源IP地址是随机的，基本上可以断定这是一次SYN攻击。在 Linux/Unix 上可以使用系统自带的 netstats 命令来检测 SYN 攻击。 1netstat -n -p TCP | grep SYN_RECV 常见的防御 SYN 攻击的方法有如下几种： 缩短超时（SYN Timeout）时间 增加最大半连接数 过滤网关防护 SYN cookies技术 1.2.2 四次挥手 为什么挥手是四次？ 总结：挥手的目的是为了让双方都正确结束传送，并且要让对方知道自己已经结束传送。 第一次挥手，客户端正确结束传输。 第二次挥手，服务器知道客户端结束传输，客户端知道了对方已经知道自己结束了传输。 第三次挥手，服务器正确结束传输，客户端知道服务器结束传输。 第四次挥手，服务器知道客户端知道了 自己已经结束传输了。 为什么有TIME_WAIT 状态？ 为了保证客户端发送的最后一个ACK报文段能够到达服务器。 因为这个ACK有可能丢失，从而导致处在LAST-ACK状态的服务器收不到对FIN-ACK的确认报文。服务器会超时重传这个FIN-ACK，接着客户端再重传一次确认，重新启动时间等待计时器。最后客户端和服务器都能正常的关闭。 假设客户端不等待2MSL，而是在发送完ACK之后直接释放关闭，一但这个ACK丢失的话，服务器就无法正常的进入关闭连接状态。 为什么有CLOSE_WAIT 状态？ ClOSE_WAIT 是因为服务器收到客户端的结束连接报文以后，他并不能马上结束连接，要发送完手上的报文以后才能断开连接，所以在CLOSE_WAIT阶段发送它的报文。 1.3 TCP的可靠性 确认和重传：接收方收到报文就会确认，发送方发送一段时间后没有收到确认就会重传。 数据校验：TCP报文头有校验和，用于校验报文是否损坏。 数据合理分片和排序：tcp会按最大传输单元(MTU)合理分片，接收方会缓存未按序到达的数据，重新排序后交给应用层。而UDP：IP数据报大于1500字节，大于MTU。这个时候发送方的IP层就需要分片，把数据报分成若干片，是的每一片都小于MTU。而接收方IP层则需要进行数据报的重组。由于UDP的特性，某一片数据丢失时，接收方便无法重组数据报，导致丢弃整个UDP数据报。 流量控制：当接收方来不及处理发送方的数据，能通过滑动窗口，提示发送方降低发送的速率，防止包丢失。 拥塞控制：当网络拥塞时，通过拥塞窗口，减少数据的发送，防止包丢失。 1.4 TCP沾包和拆包1.4.1 TCP粘包1.4.2 TCP拆包二、HTTP与HTTPS2.1 一次完整的HTTP请求是什么样的？ 建议以一个完整的HTTP请求为流程去把很多东西串联起来 域名解析 发起TCP的3次握手 建立TCP连接后发起http请求 服务器响应http请求，浏览器得到html代码 浏览器解析html代码，并请求html代码中的资源（如js、css、图片等） 浏览器对页面进行渲染呈现给用户。 2.2 DNS域名解析2.2.1 什么是域名解析？官方解释：DNS（Domain Name System，域名系统），因特网上作为域名和IP地址相互映射的一个分布式数据库，能够使用户更方便的访问互联网，而不用去记住能够被机器直接读取的IP数串。 通过主机名，最终得到该主机名对应的IP地址的过程叫做域名解析（或主机名解析）。 通俗的讲，我们更习惯于记住一个网站的名字，比如www.baidu.com,而不是记住它的ip地址，比如：167.23.102.21。 2.2.2 域名解析过程？ 请求一旦发起，若是chrome浏览器，先在浏览器找之前有没有缓存过的域名所对应的ip地址，有的话，直接跳过dns解析了，若是没有，就会找硬盘的hosts文件，看看有没有，有的话，直接找到hosts文件里面的ip 如果本地的hosts文件没有能得到对应的ip地址，浏览器会发出一个dns请求到本地dns服务器，本地dns服务器一般都是你的网络接入服务器商提供，比如中国电信，中国移动等。 查询你输入的网址的DNS请求到达本地DNS服务器之后，本地DNS服务器会首先查询它的缓存记录，如果缓存中有此条记录，就可以直接返回结果，此过程是递归的方式进行查询。如果没有，本地DNS服务器还要向DNS根服务器进行查询。 本地DNS服务器继续向域服务器发出请求，在这个例子中，请求的对象是.com域服务器。.com域服务器收到请求之后，也不会直接返回域名和IP地址的对应关系，而是告诉本地DNS服务器，你的域名的解析服务器的地址。 最后，本地DNS服务器向域名的解析服务器发出请求，这时就能收到一个域名和IP地址对应关系，本地DNS服务器不仅要把IP地址返回给用户电脑，还要把这个对应关系保存在缓存中，以备下次别的用户查询时，可以直接返回结果，加快网络访问。 总结： 浏览器缓存，系统缓存（host文件），路由器缓存，IPS服务器缓存，根域名服务器缓存，顶级域名服务器缓存，主域名服务器缓存。本地查询：递归查询全局查询：迭代查询，如果都是递归查询，那服务器的压力就太大了。 2.2.3 为什么域名解析用UDP协议？因为UDP比较快！UDP的DNS协议只要一个请求、一个应答就好了。 而使用基于TCP的DNS协议要三次握手、发送数据以及应答、四次挥手，但是UDP协议传输内容不能超过512字节。 不过客户端向DNS服务器查询域名，一般返回的内容都不超过512字节，用UDP传输即可。 2.2.4 为什么区域传送用TCP协议？因为TCP协议可靠性好啊！ 你要从主DNS上复制内容啊，你用不可靠的UDP？ 因为TCP协议传输的内容大啊，你用最大只能传512字节的UDP协议？万一同步的数据大于512字节，你怎么办？所以用TCP协议比较好！ 2.2.5 DNS负载均衡当一个网站有足够多的用户的时候，假如每次请求的资源都位于同一台机器上面，那么这台机器随时可能会崩掉。处理办法就是用DNS负载均衡技术，它的原理是在DNS服务器中为同一个主机名配置多个IP地址,在应答DNS查询时,DNS服务器对每个查询将以DNS文件中主机记录的IP地址按顺序返回不同的解析结果,将客户端的访问引导到不同的机器上去,使得不同的客户端访问不同的服务器,从而达到负载均衡的目的｡例如可以根据每台机器的负载量，该机器离用户地理位置的距离等等。 二、网络的五层/七层模型？","categories":[{"name":"面试题目","slug":"面试题目","permalink":"http://example.com/categories/%E9%9D%A2%E8%AF%95%E9%A2%98%E7%9B%AE/"}],"tags":[{"name":"面试题目","slug":"面试题目","permalink":"http://example.com/tags/%E9%9D%A2%E8%AF%95%E9%A2%98%E7%9B%AE/"},{"name":"计算机网络","slug":"计算机网络","permalink":"http://example.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"}]},{"title":"Tampermonkey","slug":"Tampermonkey","date":"2021-12-13T06:47:23.000Z","updated":"2021-12-17T17:18:08.552Z","comments":true,"path":"2021/12/13/Tampermonkey/","link":"","permalink":"http://example.com/2021/12/13/Tampermonkey/","excerpt":"谷歌浏览器很多插件使用方法","text":"Tampermonkey 插件使用你是否还在看广告？无论是优酷、芒果TV、爱奇艺，每一集都得看一次广告你是否还在因为没有会员然后看不到很多东西 本次分享一个插件Tampermonkey,就可以帮你解决这个问题~ 插件安装 选择谷歌浏览器上面...,选择更多工具，选择扩展程序 左上方,选择扩展程序，打开chorme网上商店（需要科学上网） 搜索Tampermonkey，点击然后添加到chorme 在右上角，找到你刚才添加的插件，点击获取新脚本 搜索视频vip，然后任意安装一个插件 插件使用安装完成以后，看一下效果~ 以后看电视就不受vip限制啦~ 知网pdf格式在插件中搜索知网pdf，以后看知网的文章就可以直接下载pdf啦!","categories":[{"name":"教程","slug":"教程","permalink":"http://example.com/categories/%E6%95%99%E7%A8%8B/"}],"tags":[{"name":"chorme","slug":"chorme","permalink":"http://example.com/tags/chorme/"}]},{"title":"读书笔记","slug":"book-review","date":"2021-12-03T12:05:10.000Z","updated":"2021-12-17T18:45:00.662Z","comments":true,"path":"2021/12/03/book-review/","link":"","permalink":"http://example.com/2021/12/03/book-review/","excerpt":"读书笔记","text":"Tom’s Book Review《网络是怎么连接的》《基金投资指南》","categories":[],"tags":[{"name":"Book","slug":"Book","permalink":"http://example.com/tags/Book/"}]},{"title":"论文的一些笔记","slug":"paper-review","date":"2021-12-03T12:05:10.000Z","updated":"2021-12-17T18:44:40.450Z","comments":true,"path":"2021/12/03/paper-review/","link":"","permalink":"http://example.com/2021/12/03/paper-review/","excerpt":"论文笔记、创新点、改进点","text":"Tom’s Paper Reviewstyle transfer数据集、用途改进点 多尺度特征融合浅层特征和深层特征相融合https://zhuanlan.zhihu.com/p/74710464 残差网络 –&gt; 密集连接网络 改进点文章收集 inception 和 ResNet 相结合 https://m.xzbu.com/8/view-15343830.htm","categories":[],"tags":[{"name":"paper","slug":"paper","permalink":"http://example.com/tags/paper/"}]},{"title":"视频观后感","slug":"video-review","date":"2021-12-03T12:05:10.000Z","updated":"2021-12-17T18:43:58.058Z","comments":true,"path":"2021/12/03/video-review/","link":"","permalink":"http://example.com/2021/12/03/video-review/","excerpt":"电影、电视剧、动漫等。","text":"《火影忍者》看到了100集，留个纪念。鸣人小时候啥也不会，然后认识了佐助、小樱，其中鸣人喜欢小樱，小樱喜欢佐助。大蛇丸杀死了三代火影-老爷爷 三代火影把大蛇丸的手给废了。大蛇丸找纲木给他治疗，然后一番折腾，纲木差点同意了。然后纲木回去木叶村当第五代火影。","categories":[],"tags":[{"name":"video","slug":"video","permalink":"http://example.com/tags/video/"}]},{"title":"怎么创建自己的博客？","slug":"create-blog","date":"2021-12-03T10:48:24.000Z","updated":"2021-12-17T17:18:29.296Z","comments":true,"path":"2021/12/03/create-blog/","link":"","permalink":"http://example.com/2021/12/03/create-blog/","excerpt":"在windows下创建自己的博客仓库，并且发布到github，通过访问github来访问博客。","text":"怎么创建自己的博客网站？本教程主要是适合windows下系统的开发和维护。 一、环境准备首先需要安装nodejs还有git 安装nodejs:https://www.cnblogs.com/liuqiyun/p/8133904.html 下载安装git:https://blog.csdn.net/sanxd/article/details/82624127 Hexo下载安装： 1npm install hexo-cli -g 检查是否安装成功： 1234567891011121314151617181920212223242526&gt; node -vv16.13.1&gt; npm -v8.1.2&gt; hexo -vhexo-cli: 4.3.0os: win32 10.0.19042node: 16.13.1v8: 9.4.146.24-node.14uv: 1.42.0zlib: 1.2.11brotli: 1.0.9ares: 1.18.1modules: 93nghttp2: 1.45.1napi: 8llhttp: 6.0.4openssl: 1.1.1l+quiccldr: 39.0icu: 69.1tz: 2021aunicode: 13.0ngtcp2: 0.1.0-DEVnghttp3: 0.1.0-DEV 输入指令出来结果代表环境安装顺利完成！ 二、搭建github仓库新建一个github仓库，仓库名字和用户名字一致。 格式如下：[owener name].github.io 三、生成ssh公钥和私钥，配置到github仓库打开git bash,输入如下所示： 12ssh-keygen -t rsa -C &quot;iszhangyongxin@163.com&quot;ssh-keygen -t rsa -C &quot;your email address&quot; 敲回车4次。 打开 C:\\Users\\你的用户名\\.ssh 文件夹 复制id_rsa.pub文件的内容。 接下来到github上面配置： 访问github 点击setting SSH and GPD keys Add ssh key 测试是否绑定成功打开git bash，输入1ssh -T git@github.com 如果结果为：”Hi xxxxx! You’ve successfully authenticated, but GitHub does not provide shell access.”说明绑定成功。 四、本地跑你的博客 新建一个文件夹（我是在E盘新建blog） 在blog文件夹打开 git bash 输入”hexo init”到这里完成Blog文件夹如下所示： 在git bash 输入 “hexo g”(generate), 再输入 “hexo s”(serve)。 访问 http://localhost:4000/ 就可以看到本地服务的页面了。 想把服务更新到github上面，首先修改你的 _config.yml 文件的deploy字段。 1234deploy: type: git repository: https://github.com/xxxx/xxx.github.io.git branch: main 执行 hexo d,就可以部署成功。 最后，在执行hexo s 或者 hexo d时，先执行hexo clean清理项目。 五、附加 部署完以后一般都是执行 hexo clean| hexo g | hexo s | hexo d","categories":[{"name":"教程","slug":"教程","permalink":"http://example.com/categories/%E6%95%99%E7%A8%8B/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"http://example.com/tags/Hexo/"},{"name":"Fluid","slug":"Fluid","permalink":"http://example.com/tags/Fluid/"}]}],"categories":[{"name":"英语","slug":"英语","permalink":"http://example.com/categories/%E8%8B%B1%E8%AF%AD/"},{"name":"教程","slug":"教程","permalink":"http://example.com/categories/%E6%95%99%E7%A8%8B/"},{"name":"面试题目","slug":"面试题目","permalink":"http://example.com/categories/%E9%9D%A2%E8%AF%95%E9%A2%98%E7%9B%AE/"}],"tags":[{"name":"英语","slug":"英语","permalink":"http://example.com/tags/%E8%8B%B1%E8%AF%AD/"},{"name":"谐音","slug":"谐音","permalink":"http://example.com/tags/%E8%B0%90%E9%9F%B3/"},{"name":"MAC","slug":"MAC","permalink":"http://example.com/tags/MAC/"},{"name":"教程","slug":"教程","permalink":"http://example.com/tags/%E6%95%99%E7%A8%8B/"},{"name":"redis","slug":"redis","permalink":"http://example.com/tags/redis/"},{"name":"面试题目","slug":"面试题目","permalink":"http://example.com/tags/%E9%9D%A2%E8%AF%95%E9%A2%98%E7%9B%AE/"},{"name":"操作系统","slug":"操作系统","permalink":"http://example.com/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"},{"name":"数据库","slug":"数据库","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"计算机网络","slug":"计算机网络","permalink":"http://example.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"},{"name":"chorme","slug":"chorme","permalink":"http://example.com/tags/chorme/"},{"name":"Book","slug":"Book","permalink":"http://example.com/tags/Book/"},{"name":"paper","slug":"paper","permalink":"http://example.com/tags/paper/"},{"name":"video","slug":"video","permalink":"http://example.com/tags/video/"},{"name":"Hexo","slug":"Hexo","permalink":"http://example.com/tags/Hexo/"},{"name":"Fluid","slug":"Fluid","permalink":"http://example.com/tags/Fluid/"}]}